{
  Assert.notNull(serviceTicketId,"serviceTicketId cannot be null");
  Assert.notNull(service,"service cannot be null");
  final ServiceTicket serviceTicket=this.serviceTicketRegistry.getTicket(serviceTicketId,ServiceTicket.class);
  final RegisteredService registeredService=this.servicesManager.findServiceBy(service);
  if (registeredService == null || !registeredService.isEnabled()) {
    final String msg=String.format("ServiceManagement: Service [%s] does not exist or is not enabled" + " and thus not allowed to validate tickets.",service.getId());
    logger.warn(msg);
    throw UnauthorizedServiceException.UNAUTHZ_SVC_EXCEPTION;
  }
  if (serviceTicket == null) {
    logger.info("ServiceTicket [{}] does not exist.",serviceTicketId);
    throw new InvalidTicketException(serviceTicketId);
  }
  try {
synchronized (serviceTicket) {
      if (serviceTicket.isExpired()) {
        logger.info("ServiceTicket [{}] has expired.",serviceTicketId);
        throw new InvalidTicketException(serviceTicketId);
      }
      if (!serviceTicket.isValidFor(service)) {
        logger.error("ServiceTicket [{}] with service [{}] does not match supplied service [{}]",serviceTicketId,serviceTicket.getService().getId(),service);
        throw new TicketValidationException(serviceTicket.getService());
      }
    }
    final TicketGrantingTicket root=serviceTicket.getGrantingTicket().getRoot();
    final Authentication authentication=getAuthenticationSatisfiedByPolicy(root,new ServiceContext(serviceTicket.getService(),registeredService));
    final Principal principal=authentication.getPrincipal();
    Map<String,Object> attributesToRelease=this.defaultAttributeFilter.filter(principal.getId(),principal.getAttributes(),registeredService);
    if (registeredService.getAttributeFilter() != null) {
      attributesToRelease=registeredService.getAttributeFilter().filter(principal.getId(),attributesToRelease,registeredService);
    }
    final String principalId=determinePrincipalIdForRegisteredService(principal,registeredService,serviceTicket);
    final Principal modifiedPrincipal=new SimplePrincipal(principalId,attributesToRelease);
    final AuthenticationBuilder builder=AuthenticationBuilder.newInstance(authentication);
    builder.setPrincipal(modifiedPrincipal);
    return new ImmutableAssertion(builder.build(),root.getChainedAuthentications(),serviceTicket.getService(),serviceTicket.isFromNewLogin());
  }
  finally {
    if (serviceTicket.isExpired()) {
      this.serviceTicketRegistry.deleteTicket(serviceTicketId);
    }
  }
}

{
  Assert.notNull(service,"service cannot be null");
  final TicketGrantingTicket ticketGrantingTicket=getTicket(ticketGrantingTicketId,TicketGrantingTicket.class);
  final RegisteredService registeredService=this.servicesManager.findServiceBy(service);
  verifyRegisteredServiceProperties(registeredService,service);
  Authentication currentAuthentication=null;
  if (credentials != null && credentials.length > 0) {
    currentAuthentication=this.authenticationManager.authenticate(credentials);
    final Authentication original=ticketGrantingTicket.getAuthentication();
    if (!currentAuthentication.getPrincipal().equals(original.getPrincipal())) {
      throw new MixedPrincipalException(currentAuthentication,currentAuthentication.getPrincipal(),original.getPrincipal());
    }
    ticketGrantingTicket.getSupplementalAuthentications().add(currentAuthentication);
  }
  if (currentAuthentication == null && !registeredService.getAuthorizationStrategy().isServiceAuthorizedForSso(service)) {
    logger.warn("ServiceManagement: Service [{}] is not allowed to use SSO.",service.getId());
    throw new UnauthorizedSsoServiceException();
  }
  final List<Authentication> authns=ticketGrantingTicket.getChainedAuthentications();
  if (authns.size() > 1) {
    if (!registeredService.getProxyPolicy().isAllowedToProxy()) {
      final String message=String.format("ServiceManagement: Proxy attempt by service [%s] (registered service [%s]) is not allowed.",service.getId(),registeredService.toString());
      logger.warn(message);
      throw new UnauthorizedProxyingException(message);
    }
  }
  getAuthenticationSatisfiedByPolicy(ticketGrantingTicket,new ServiceContext(service,registeredService));
  final String uniqueTicketIdGenKey=service.getClass().getName();
  if (!this.uniqueTicketIdGeneratorsForService.containsKey(uniqueTicketIdGenKey)) {
    logger.warn("Cannot create service ticket because the key [{}] for service [{}] is not linked to a ticket id generator",uniqueTicketIdGenKey,service.getId());
    throw new UnauthorizedSsoServiceException();
  }
  final List<Authentication> authentications=ticketGrantingTicket.getChainedAuthentications();
  final Principal principal=authentications.get(authentications.size() - 1).getPrincipal();
  final Map<String,Object> principalAttrs=registeredService.getAttributeReleasePolicy().getAttributes(principal);
  if (!registeredService.getAuthorizationStrategy().isServiceAccessAuthorizedForPrincipal(principalAttrs,service)) {
    logger.warn("ServiceManagement: Cannot grant service ticket because Service [{}] is not authorized for use by [{}].",service.getId(),principal);
    throw new UnauthorizedServiceForPrincipalException();
  }
  final UniqueTicketIdGenerator serviceTicketUniqueTicketIdGenerator=this.uniqueTicketIdGeneratorsForService.get(uniqueTicketIdGenKey);
  final String ticketPrefix=authentications.size() == 1 ? ServiceTicket.PREFIX : ServiceTicket.PROXY_TICKET_PREFIX;
  final String ticketId=serviceTicketUniqueTicketIdGenerator.getNewTicketId(ticketPrefix);
  final ServiceTicket serviceTicket=ticketGrantingTicket.grantServiceTicket(ticketId,service,this.serviceTicketExpirationPolicy,currentAuthentication != null);
  this.serviceTicketRegistry.addTicket(serviceTicket);
  logger.info("Granted ticket [{}] for service [{}] for user [{}]",serviceTicket.getId(),service.getId(),principal.getId());
  return serviceTicket;
}

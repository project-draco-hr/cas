{
  try {
    final String providerName=System.getProperty("jsr105Provider",SIGNATURE_FACTORY_PROVIDER_CLASS);
    final XMLSignatureFactory sigFactory=XMLSignatureFactory.getInstance("DOM",(Provider)Class.forName(providerName).newInstance());
    final List<Transform> envelopedTransform=Collections.singletonList(sigFactory.newTransform(Transform.ENVELOPED,(TransformParameterSpec)null));
    final Reference ref=sigFactory.newReference("",sigFactory.newDigestMethod(DigestMethod.SHA1,null),envelopedTransform,null,null);
    final SignatureMethod signatureMethod;
    if (pubKey instanceof DSAPublicKey) {
      signatureMethod=sigFactory.newSignatureMethod(SignatureMethod.DSA_SHA1,null);
    }
 else     if (pubKey instanceof RSAPublicKey) {
      signatureMethod=sigFactory.newSignatureMethod(SignatureMethod.RSA_SHA1,null);
    }
 else {
      throw new RuntimeException("Error signing SAML element: Unsupported type of key");
    }
    final CanonicalizationMethod canonicalizationMethod=sigFactory.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE_WITH_COMMENTS,(C14NMethodParameterSpec)null);
    final SignedInfo signedInfo=sigFactory.newSignedInfo(canonicalizationMethod,signatureMethod,Collections.singletonList(ref));
    final KeyInfoFactory keyInfoFactory=sigFactory.getKeyInfoFactory();
    final KeyValue keyValuePair=keyInfoFactory.newKeyValue(pubKey);
    final KeyInfo keyInfo=keyInfoFactory.newKeyInfo(Collections.singletonList(keyValuePair));
    final org.w3c.dom.Element w3cElement=toDom(element);
    final DOMSignContext dsc=new DOMSignContext(privKey,w3cElement);
    final org.w3c.dom.Node xmlSigInsertionPoint=getXmlSignatureInsertLocation(w3cElement);
    dsc.setNextSibling(xmlSigInsertionPoint);
    final XMLSignature signature=sigFactory.newXMLSignature(signedInfo,keyInfo);
    signature.sign(dsc);
    return toJdom(w3cElement);
  }
 catch (  final Exception e) {
    throw new RuntimeException("Error signing SAML element: " + e.getMessage(),e);
  }
}

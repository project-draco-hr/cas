{
  final List<String> supportedNameFormats=adaptor.getSupportedNameFormats();
  logger.debug("Metadata for [{}] declares support for the following NameIDs [{}]",adaptor.getEntityId(),supportedNameFormats);
  if (supportedNameFormats.isEmpty()) {
    supportedNameFormats.add(NameIDType.TRANSIENT);
  }
  String requiredNameFormat=null;
  if (authnRequest.getNameIDPolicy() != null) {
    requiredNameFormat=authnRequest.getNameIDPolicy().getFormat();
    logger.debug("AuthN request says [{}] is the required NameID format",requiredNameFormat);
    if (NameID.ENCRYPTED.equals(requiredNameFormat)) {
      logger.warn("Encrypted NameID formats are not supported");
      requiredNameFormat=null;
    }
  }
  final Map<String,Object> principalAttributes=assertion.getPrincipal().getAttributes();
  if (principalAttributes.isEmpty() && StringUtils.isNotBlank(requiredNameFormat)) {
    logger.warn("No CAS attributes for CAS principal [{}], so no name identifier will be created.",assertion.getPrincipal().getName());
    throw new SamlException("No attributes for principal, so NameID format required can not be supported");
  }
  if (StringUtils.isNotBlank(requiredNameFormat) && !supportedNameFormats.contains(requiredNameFormat)) {
    logger.warn("Required NameID format [{}] in the AuthN request issued by [{}] is not supported based on the metadata for [{}]",requiredNameFormat,authnRequest.getIssuer().getValue(),adaptor.getEntityId());
    throw new SamlException("Required NameID format cannot be provided because it is not supported");
  }
  try {
    for (    final String nameFormat : supportedNameFormats) {
      final SAML2StringNameIDEncoder encoder=new SAML2StringNameIDEncoder();
      encoder.setNameFormat(nameFormat);
      if (authnRequest.getNameIDPolicy() != null) {
        encoder.setNameQualifier(authnRequest.getNameIDPolicy().getSPNameQualifier());
      }
      final IdPAttribute attribute=new IdPAttribute(AttributePrincipal.class.getName());
      final IdPAttributeValue<String> value=new StringAttributeValue(assertion.getPrincipal().getName());
      attribute.setValues(Collections.singletonList(value));
      return encoder.encode(attribute);
    }
  }
 catch (  final Exception e) {
    logger.error(e.getMessage(),e);
  }
  return null;
}

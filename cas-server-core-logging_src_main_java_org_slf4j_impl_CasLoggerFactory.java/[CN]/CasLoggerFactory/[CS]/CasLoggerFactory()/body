{
  this.loggerMap=new ConcurrentHashMap<>();
  final Collection<URL> set=ClasspathHelper.forPackage(PACKAGE_TO_SCAN);
  final Reflections reflections=new Reflections(new ConfigurationBuilder().addUrls(set).setScanners(new SubTypesScanner()));
  final Set<Class<? extends ILoggerFactory>> subTypesOf=reflections.getSubTypesOf(ILoggerFactory.class);
  subTypesOf.remove(this.getClass());
  if (subTypesOf.size() > 1) {
    Util.report("Multiple ILoggerFactory bindings are found on the classpath:");
    for (    final Class<? extends ILoggerFactory> c : subTypesOf) {
      Util.report("* " + c.getCanonicalName());
    }
  }
  if (subTypesOf.isEmpty()) {
    final RuntimeException e=new RuntimeException("No ILoggerFactory could be found on the classpath." + " CAS cannot determine the logging framework." + " Examine the project dependencies and ensure that there is one and only one logging framework available.");
    Util.report(e.getMessage(),e);
    throw e;
  }
  this.realLoggerFactoryClass=null;
  for (  final Class<? extends ILoggerFactory> factory : subTypesOf) {
    if (getLoggerFactoryBeInstantiated(factory) != null) {
      this.realLoggerFactoryClass=factory;
      Util.report("ILoggerFactory to be used for logging is: " + this.realLoggerFactoryClass.getName());
      break;
    }
 else {
      Util.report("ILoggerFactory [" + factory.getName() + "] could not be used. Trying the next ILoggerFactory...");
    }
  }
  if (this.realLoggerFactoryClass == null) {
    throw new RuntimeException("No ILoggerFactory is available to use. Log configuration is incorrect, " + "or multiple logging frameworks are at conflict with one another on the classpath.");
  }
}

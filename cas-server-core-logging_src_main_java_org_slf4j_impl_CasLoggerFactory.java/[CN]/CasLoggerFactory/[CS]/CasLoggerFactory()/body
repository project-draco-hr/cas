{
  this.loggerMap=new ConcurrentHashMap<>();
  Set<Class<? extends ILoggerFactory>> loggerFactories=lookUpConfiguredLoggerFactory();
  if (loggerFactories.isEmpty()) {
    loggerFactories=scanContextForLoggerFactories();
  }
  if (loggerFactories.size() > 1) {
    Util.report("Multiple ILoggerFactory bindings are found on the classpath:");
    for (    final Class<? extends ILoggerFactory> c : loggerFactories) {
      Util.report("* " + c.getCanonicalName());
    }
    Util.report("This generally indicates a configuration problem which is a result of dependency conflicts.");
    Util.report("If you wish to use a different logging framework, specify the ILoggerFactory binding via -D" + ENVIRONMENT_VAR_LOGGER_FACTORY + "=<binding-class> to the runtime environment");
  }
  if (loggerFactories.isEmpty()) {
    final RuntimeException e=new RuntimeException("No ILoggerFactory could be found on the classpath." + " CAS cannot determine the logging framework." + " Examine the project dependencies and ensure that there is one and only one logging framework available.");
    Util.report(e.getMessage(),e);
    throw e;
  }
  this.realLoggerFactoryClass=null;
  for (  final Class<? extends ILoggerFactory> factory : loggerFactories) {
    Util.report("Attempting to locate ILoggerFactory instance from: " + factory.getName());
    if (getLoggerFactoryBeInstantiated(factory) != null) {
      this.realLoggerFactoryClass=factory;
      Util.report("ILoggerFactory to be used for logging is: " + this.realLoggerFactoryClass.getName());
      break;
    }
 else {
      Util.report("ILoggerFactory [" + factory.getName() + "] could not be used. Trying the next ILoggerFactory...");
    }
  }
  if (this.realLoggerFactoryClass == null) {
    throw new RuntimeException("No ILoggerFactory is available to use. Log configuration is incorrect, " + "or multiple logging frameworks are at conflict with one another on the classpath.");
  }
}

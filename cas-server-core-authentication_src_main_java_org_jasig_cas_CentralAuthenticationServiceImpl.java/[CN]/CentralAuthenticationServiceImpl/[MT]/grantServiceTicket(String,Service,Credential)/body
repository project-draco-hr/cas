{
  final TicketGrantingTicket ticketGrantingTicket=getTicket(ticketGrantingTicketId,TicketGrantingTicket.class);
  final RegisteredService registeredService=this.servicesManager.findServiceBy(service);
  verifyRegisteredServiceProperties(registeredService,service);
  final Set<Credential> sanitizedCredentials=sanitizeCredentials(credentials);
  Authentication currentAuthentication=null;
  if (!sanitizedCredentials.isEmpty()) {
    currentAuthentication=this.authenticationManager.authenticate(sanitizedCredentials.toArray(new Credential[]{}));
    final Authentication original=ticketGrantingTicket.getAuthentication();
    if (!currentAuthentication.getPrincipal().equals(original.getPrincipal())) {
      throw new MixedPrincipalException(currentAuthentication,currentAuthentication.getPrincipal(),original.getPrincipal());
    }
    ticketGrantingTicket.getSupplementalAuthentications().add(currentAuthentication);
  }
  if (currentAuthentication == null && !registeredService.getAccessStrategy().isServiceAccessAllowedForSso()) {
    logger.warn("ServiceManagement: Service [{}] is not allowed to use SSO.",service.getId());
    throw new UnauthorizedSsoServiceException();
  }
  evaluateProxiedServiceIfNeeded(service,ticketGrantingTicket,registeredService);
  getAuthenticationSatisfiedByPolicy(ticketGrantingTicket,new ServiceContext(service,registeredService));
  final List<Authentication> authentications=ticketGrantingTicket.getChainedAuthentications();
  final Principal principal=authentications.get(authentications.size() - 1).getPrincipal();
  final Map<String,Object> principalAttrs=registeredService.getAttributeReleasePolicy().getAttributes(principal);
  if (!registeredService.getAccessStrategy().doPrincipalAttributesAllowServiceAccess(principalAttrs)) {
    logger.warn("ServiceManagement: Cannot grant service ticket because Service [{}] is not authorized for use by [{}].",service.getId(),principal);
    throw new UnauthorizedServiceForPrincipalException();
  }
  final String uniqueTicketIdGenKey=service.getClass().getName();
  logger.debug("Looking up service ticket id generator for [{}]",uniqueTicketIdGenKey);
  UniqueTicketIdGenerator serviceTicketUniqueTicketIdGenerator=this.uniqueTicketIdGeneratorsForService.get(uniqueTicketIdGenKey);
  if (serviceTicketUniqueTicketIdGenerator == null) {
    serviceTicketUniqueTicketIdGenerator=this.defaultServiceTicketIdGenerator;
    logger.debug("Service ticket id generator not found for [{}]. Using the default generator...",uniqueTicketIdGenKey);
  }
  final String ticketPrefix=authentications.size() == 1 ? ServiceTicket.PREFIX : ServiceTicket.PROXY_TICKET_PREFIX;
  final String ticketId=serviceTicketUniqueTicketIdGenerator.getNewTicketId(ticketPrefix);
  final ServiceTicket serviceTicket=ticketGrantingTicket.grantServiceTicket(ticketId,service,this.serviceTicketExpirationPolicy,currentAuthentication != null,this.onlyTrackMostRecentSession);
  this.ticketRegistry.addTicket(serviceTicket);
  logger.info("Granted ticket [{}] for service [{}] for user [{}]",serviceTicket.getId(),service.getId(),principal.getId());
  return serviceTicket;
}
